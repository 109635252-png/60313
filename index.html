<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <title>çµ•åœ°æ±‚ç”Ÿ (æ­¦å™¨ç³»çµ±)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans TC', sans-serif;
            margin: 0;
            background-color: #000;
            color: #fff;
            overflow: hidden; /* éš±è—æ»¾å‹•æ¢ */
        }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
        }
        #instructions {
            width: 80%;
            max-width: 600px;
            cursor: pointer;
        }
        #instructions h1 {
            font-size: 3em;
        }
        #instructions p {
            font-size: 1.2em;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px; /* èª¿æ•´å¤§å° */
            height: 8px;
            border: 2px solid rgba(255, 255, 255, 0.7); /* ç¨ç´°ã€åŠé€æ˜ */
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 5px rgba(0,0,0,0.8); /* åŠ ä¸Šé™°å½±ä»¥æ‡‰å°äº®èƒŒæ™¯ */
            z-index: 10;
            display: none; /* é è¨­éš±è— */
        }
        
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 1.5em;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 8px;
            z-index: 10;
            display: none; /* é è¨­éš±è— */
            min-width: 200px;
        }
        .hud-item {
            margin-bottom: 5px;
        }
        
        /* æ‰‹æ©Ÿè§¸æ§ UI */
        #touch-controls {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
        }

        #joystick-area {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 150px;
            height: 150px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            pointer-events: auto;
        }

        #joystick-handle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 70px;
            height: 70px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.1s;
        }

        #action-buttons {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: auto;
        }

        #action-buttons button {
            width: 65px;
            height: 65px;
            margin: 8px 0;
            font-size: 2em;
            background-color: rgba(255, 255, 255, 0.3); /* æ›´é€æ˜ */
            border: 1px solid rgba(255, 255, 255, 0.4); /* åŠ ä¸Šé‚Šæ¡† */
            border-radius: 50%;
            color: white;
            padding: 0;
            line-height: 65px;
            text-align: center;
            user-select: none; /* é˜²æ­¢é¸å–æ–‡å­— */
            backdrop-filter: blur(5px); /* æ¯›ç»ç’ƒæ•ˆæœ */
            transition: background-color 0.1s;
        }

        /* *** æ–°å¢: åˆ‡æ›æ­¦å™¨æŒ‰éˆ•çš„å¤§å° *** */
        #switch-weapon-button {
            width: 60px;
            height: 60px;
            line-height: 60px;
            font-size: 1.8em;
            margin-top: 15px; /* æŠŠå®ƒæ”¾åœ¨æœ€ä¸Šé¢ */
            order: -1; /* è®“å®ƒé¡¯ç¤ºåœ¨æœ€ä¸Šé¢ */
        }
        
        #action-buttons button:active {
            background-color: rgba(255, 255, 255, 0.6);
        }
        
        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0);
            z-index: 50;
            pointer-events: none;
            transition: background-color 0.1s ease-out;
        }

        /* è¦–è§’åˆ‡æ›æŒ‰éˆ• */
        #view-toggle-button {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            font-size: 1.2em;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            z-index: 10;
            backdrop-filter: blur(5px);
            display: none; /* éŠæˆ²é–‹å§‹å¾Œæ‰é¡¯ç¤º */
        }
        #view-toggle-button:active {
            background-color: rgba(0, 0, 0, 0.7);
        }
    </style>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <h1>çµ•åœ°æ±‚ç”Ÿ (æ­¦å™¨ç³»çµ±)</h1>
            <p id="start-prompt" style="font-size: 1.5em;">é»æ“Šè¢å¹•é–‹å§‹éŠæˆ²</p>
            <p id="controls-info">
                W, A, S, D = ç§»å‹•<br/>
                Shift = æ»‘éŸ (éœ€å‘å‰ç§»å‹•æ™‚)<br/>
                ç©ºç™½éµ = è·³èº<br/>
                æ»‘é¼  = ç’°é¡§å››å‘¨<br/>
                æ»‘é¼ å·¦éµ = å°„æ“Š / æ”»æ“Š<br/>
                æ»‘é¼ æ»¾è¼ª = ç¸®æ”¾ç„æº–<br/>
                R = æ›å½ˆ<br/>
                ESC = è§£é–æ»‘é¼ <br/>
                V = åˆ‡æ›è¦–è§’ (ç¬¬ä¸€/ç¬¬ä¸‰äººç¨±)<br/>
                1, 2, 3 = åˆ‡æ›æ­¦å™¨ (é•·æ§/æ‰‹æ§/åŠ)
            </p>
        </div>
    </div>

    <div id="damage-overlay"></div>
    
    <div id="crosshair"></div>
    <div id="hud">
        <div class="hud-item">â¤ï¸ è¡€é‡: <span id="health">100</span></div>
        <div class="hud-item">å½ˆè—¥: <span id="ammo">100 / 100</span></div>
        <div class="hud-item">ğŸ¯ åˆ†æ•¸: <span id="score">0</span></div>
    </div>
    
    <div id="touch-controls" style="display: none;">
        <div id="joystick-area">
            <div id="joystick-handle"></div>
        </div>
        <div id="action-buttons">
            <!-- *** æ–°å¢: åˆ‡æ›æ­¦å™¨æŒ‰éˆ• *** -->
            <button id="switch-weapon-button">ğŸ”</button>
            <button id="shoot-button">ğŸ”«</button>
            <button id="reload-button">ğŸ”„</button>
            <button id="slide-button">ğŸƒ</button>
            <button id="jump-button">ğŸ”¼</button>
        </div>
    </div>

    <button id="view-toggle-button">ç¬¬ä¸‰äººç¨±</button> <!-- è¦–è§’åˆ‡æ›æŒ‰éˆ• --><script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { PointerLockControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/PointerLockControls.js';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js'; // å¼•å…¥ OrbitControls

        let camera, scene, renderer, controls;
        let fpControls; // ç¬¬ä¸€äººç¨±æ§åˆ¶
        let tpControls; // ç¬¬ä¸‰äººç¨±æ§åˆ¶
        let isFirstPerson = true; // é è¨­ç‚ºç¬¬ä¸€äººç¨±

        let playerBody; // ç©å®¶çš„å¯¦éš›æ¨¡å‹ (ç¬¬ä¸‰äººç¨±æ™‚å¯è¦‹)
        
        // --- æ­¦å™¨ç³»çµ± ---
        let weaponHolder; // å®¹ç´æ‰€æœ‰æ­¦å™¨çš„ç¾¤çµ„
        let weapons = []; // å„²å­˜æ­¦å™¨è³‡æ–™
        let currentWeaponIndex = 0; // ç›®å‰æ­¦å™¨ç´¢å¼•
        let muzzleFlash;
        // ---

        let objects = []; // ç”¨æ–¼ç¢°æ’åµæ¸¬ (åœ°æ¿ã€éšœç¤™ç‰©)
        let groundObjects = []; // å°ˆé–€ç”¨æ–¼åœ°é¢åµæ¸¬
        let targets = []; // å°ˆé–€å­˜æ”¾ç›®æ¨™æ–¹å¡Š (æ•µäºº)
        let raycaster;
        

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let isReloading = false;
        let isSliding = false;
        let slideCooldown = 0;
        let isShooting = false;
        let lastShotTime = 0;

        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // ç©å®¶ç‹€æ…‹
        let score = 0;
        let health = 100;
        // (å½ˆè—¥è®Šæ•¸ç§»è‡³ weapons é™£åˆ—)
        let lastDamageTime = 0;

        // --- æ•ˆèƒ½å„ªåŒ–ï¼šç¢°æ’åµæ¸¬ç‰©ä»¶ ---
        let playerCollider = new THREE.Box3();
        let playerColliderCenter = new THREE.Vector3();
        let playerColliderSize = new THREE.Vector3();
        // ------------------------------

        // æ‰‹æ©Ÿæ§åˆ¶ç›¸é—œ
        const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        const PI_2 = Math.PI / 2;
        let lookTouchId = -1;
        const lookLastPos = new THREE.Vector2();
        const joystick = { active: false, initial: new THREE.Vector2(), delta: new THREE.Vector2() };

        // HUD Elements
        const scoreElement = document.getElementById('score');
        const healthElement = document.getElementById('health');
        const ammoElement = document.getElementById('ammo');
        const hudElement = document.getElementById('hud');
        const crosshairElement = document.getElementById('crosshair');
        const damageOverlayElement = document.getElementById('damage-overlay');
        const viewToggleButton = document.getElementById('view-toggle-button');

        // Texture Loader
        const textureLoader = new THREE.TextureLoader();

        init();
        animate();

        function init() {
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(100, 10, 130); // ç¨å¾®èª¿æ•´åˆå§‹é¡é ­
            
            scene = new THREE.Scene();
            
            // --- å¤©ç©ºç›’ ---
            const skyboxTextures = [
                'https://threejs.org/examples/textures/cube/Bridge2/posx.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/negx.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/posy.jpg', // Up
                'https://threejs.org/examples/textures/cube/Bridge2/negy.jpg', // Down
                'https://threejs.org/examples/textures/cube/Bridge2/posz.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/negz.jpg',
            ];
            const cubeTextureLoader = new THREE.CubeTextureLoader();
            scene.background = cubeTextureLoader.load(skyboxTextures);
            // -----------

            scene.fog = new THREE.Fog(0xcce0ff, 0, 750); // éœ§çš„é¡è‰²èª¿æ•´ç‚ºæ›´é…åˆå¤©ç©º

            const light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.9);
            light.position.set(0.5, 1, 0.75);
            scene.add(light);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight.position.set(-100, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 100;
            dirLight.shadow.camera.bottom = -100;
            dirLight.shadow.camera.left = -100;
            dirLight.shadow.camera.right = 100;
            scene.add(dirLight);

            raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 10);

            // --- åœ°æ¿ (è‰çš®) ---
            textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg', (grassTexture) => { // æ›æˆç¶ è‰²è‰åœ°
                grassTexture.wrapS = THREE.RepeatWrapping;
                grassTexture.wrapT = THREE.RepeatWrapping;
                grassTexture.repeat.set(200, 200); // é‡è¤‡è²¼åœ–
                const floor = new THREE.Mesh(
                    new THREE.PlaneGeometry(2000, 2000, 100, 100),
                    new THREE.MeshLambertMaterial({ map: grassTexture })
                );
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                scene.add(floor);
                groundObjects.push(floor);
                objects.push(floor); // åœ°æ¿ä¹Ÿè¦åƒèˆ‡ä¸€èˆ¬ç¢°æ’
            });
            // ------------------

            // ç‰†å£å’Œéšœç¤™ç‰©
            const boxGeometry = new THREE.BoxGeometry(20, 20, 20);
            for (let i = 0; i < 50; i++) {
                const box = new THREE.Mesh(boxGeometry, new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff }));
                box.position.set(Math.floor(Math.random() * 20 - 10) * 20, 10, Math.floor(Math.random() * 20 - 10) * 20);
                box.castShadow = true;
                box.receiveShadow = true;
                scene.add(box);
                objects.push(box); 
                groundObjects.push(box); 
            }

            // ç©å®¶çš„ç¬¬ä¸‰äººç¨±æ¨¡å‹
            const playerGeometry = new THREE.BoxGeometry(4, 18, 4); // è¨­ç‚ºä¸€å€‹ç´°é•·çš„ç›’å­ä»£è¡¨ç©å®¶èº«é«”
            const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x0077ff });
            playerBody = new THREE.Mesh(playerGeometry, playerMaterial);
            playerBody.position.set(100, 9, 100); 
            playerBody.castShadow = true;
            playerBody.receiveShadow = true;
            scene.add(playerBody);
            
            // --- æ­¦å™¨æ¨¡å‹ç³»çµ± ---
            weaponHolder = new THREE.Group();
            weaponHolder.position.set(0.5, -0.4, -1.2); // FP é è¨­ä½ç½®
            weaponHolder.rotation.y = -0.1;

            const gunMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.8 });
            const swordMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.2, metalness: 1.0 });

            // 1. é•·æ§ (Rifle)
            const rifleModel = new THREE.Group();
            const rifleBody = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 1), gunMaterial);
            const rifleBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.8, 16), gunMaterial);
            rifleBarrel.position.z = -0.9;
            rifleBarrel.rotation.x = Math.PI / 2;
            rifleModel.add(rifleBody, rifleBarrel);
            
            muzzleFlash = new THREE.PointLight(0xffa500, 0, 50, 2);
            muzzleFlash.position.set(0, 0, -0.8);
            rifleBarrel.add(muzzleFlash); // æ§å£ç«ç„°åªåŠ åœ¨é•·æ§ä¸Š
            
            // 2. æ‰‹æ§ (Pistol)
            const pistolModel = new THREE.Group();
            const pistolBody = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.5), gunMaterial);
            const pistolBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.4, 16), gunMaterial);
            pistolBarrel.position.z = -0.45;
            pistolBarrel.rotation.x = Math.PI / 2;
            pistolModel.add(pistolBody, pistolBarrel);
            pistolModel.visible = false; // é è¨­éš±è—

            // 3. åŠ (Sword)
            const swordModel = new THREE.Group();
            const swordBlade = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.2, 1.5), swordMaterial);
            swordBlade.position.z = -0.6;
            const swordHilt = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.3), gunMaterial);
            swordHilt.position.z = 0.3;
            const swordGuard = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.3, 0.1), gunMaterial);
            swordGuard.position.z = 0.1;
            swordModel.add(swordBlade, swordHilt, swordGuard);
            swordModel.visible = false; // é è¨­éš±è—

            // å°‡æ‰€æœ‰æ­¦å™¨åŠ å…¥ weaponHolder
            weaponHolder.add(rifleModel);
            weaponHolder.add(pistolModel);
            weaponHolder.add(swordModel);
            camera.add(weaponHolder); // é è¨­æ­¦å™¨åœ¨ç¬¬ä¸€äººç¨±æ”å½±æ©Ÿä¸Š

            // åˆå§‹åŒ–æ­¦å™¨è³‡æ–™
            weapons = [
                { 
                    name: 'Rifle', 
                    model: rifleModel, 
                    ammo: 100, 
                    maxAmmo: 100, 
                    fireRate: 150, // ms
                    reloadTime: 1500, // ms
                    type: 'raycast' 
                },
                { 
                    name: 'Pistol', 
                    model: pistolModel, 
                    ammo: 15, 
                    maxAmmo: 15, 
                    fireRate: 400,
                    reloadTime: 1000,
                    type: 'raycast' 
                },
                { 
                    name: 'Sword', 
                    model: swordModel, 
                    ammo: 0, // N/A
                    maxAmmo: 0, // N/A
                    fireRate: 500, // attack speed
                    reloadTime: 0,
                    type: 'melee',
                    range: 12 // melee range
                }
            ];
            // --- æ­¦å™¨ç³»çµ±çµæŸ ---
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');

            // --- ç¬¬ä¸€äººç¨±æ§åˆ¶å™¨ ---
            fpControls = new PointerLockControls(camera, document.body);
            // --------------------

            // --- ç¬¬ä¸‰äººç¨±æ§åˆ¶å™¨ ---
            tpControls = new OrbitControls(camera, renderer.domElement);
            tpControls.enableDamping = true;
            tpControls.dampingFactor = 0.25;
            tpControls.maxDistance = 50;
            tpControls.minDistance = 10;
            tpControls.target.copy(playerBody.position);
            tpControls.enabled = false;
            // --------------------

            // åˆå§‹æ•µäºº
            for (let i = 0; i < 50; i++) spawnTarget();

            if (isMobile) {
                document.getElementById('touch-controls').style.display = 'block';
                document.getElementById('controls-info').innerHTML = 'å·¦å´æ–æ¡¿ = ç§»å‹•<br/>å³å´è¢å¹• = è½‰å‹•è¦–è§’<br/>å³ä¸‹è§’æŒ‰éˆ• = å„é …å‹•ä½œ<br/>å·¦ä¸Šè§’æŒ‰éˆ• = åˆ‡æ›è¦–è§’<br/>å³ä¸Šè§’æŒ‰éˆ• = å¾ªç’°åˆ‡æ›æ­¦å™¨';
                instructions.addEventListener('click', startGame);
                setupTouchControls();
            } else {
                scene.add(fpControls.getObject()); 
                instructions.addEventListener('click', () => fpControls.lock());
                fpControls.addEventListener('lock', () => { 
                    instructions.style.display = 'none'; 
                    blocker.style.display = 'none'; 
                    hudElement.style.display = 'block'; 
                    crosshairElement.style.display = 'block'; 
                    viewToggleButton.style.display = 'block';
                });
                fpControls.addEventListener('unlock', () => { 
                    blocker.style.display = 'flex'; 
                    instructions.style.display = ''; 
                    hudElement.style.display = 'none'; 
                    crosshairElement.style.display = 'none'; 
                    viewToggleButton.style.display = 'none';
                });
                document.addEventListener('mousedown', (e) => { 
                    // *** ä¿®æ­£: å‘¼å« isGameActive ***
                    if (isGameActive()) onPrimaryAction(e); // çµ±ä¸€å‘¼å«
                });
            }
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('wheel', onMouseWheel);
            window.addEventListener('resize', onWindowResize);

            viewToggleButton.addEventListener('click', toggleView);
            document.addEventListener('keydown', (event) => {
                // *** ä¿®æ­£: å‘¼å« isGameActive ***
                if (event.code === 'KeyV' && isGameActive()) {
                    toggleView();
                }
            });

            // åˆå§‹ HUD
            updateAmmoHUD();
        }

        function isGameActive() {
             return isMobile ? (document.getElementById('blocker').style.display === 'none') : fpControls.isLocked || !isFirstPerson;
        }

        function startGame() {
            document.getElementById('blocker').style.display = 'none';
            hudElement.style.display = 'block';
            crosshairElement.style.display = 'block';
            viewToggleButton.style.display = 'block';
        }

        function toggleView() {
            isFirstPerson = !isFirstPerson;
            if (isFirstPerson) {
                // å¾ç¬¬ä¸‰äººç¨±åˆ‡æ›åˆ°ç¬¬ä¸€äººç¨±
                viewToggleButton.textContent = 'ç¬¬ä¸‰äººç¨±';
                crosshairElement.style.display = 'block';
                camera.position.copy(playerBody.position); 
                camera.rotation.set(0, 0, 0); 
                fpControls.getObject().position.copy(playerBody.position); 
                fpControls.getObject().rotation.copy(camera.rotation);
                scene.add(fpControls.getObject()); 
                playerBody.visible = false; 
                // *** ä¿®æ­£: ç§»å‹• weaponHolder ***
                weaponHolder.position.set(0.5, -0.4, -1.2); 
                weaponHolder.rotation.y = -0.1;
                camera.add(weaponHolder); 
                // ***
                tpControls.enabled = false;
                if (!isMobile) fpControls.lock();
            } else {
                // å¾ç¬¬ä¸€äººç¨±åˆ‡æ›åˆ°ç¬¬ä¸‰äººç¨±
                viewToggleButton.textContent = 'ç¬¬ä¸€äººç¨±';
                crosshairElement.style.display = 'none'; 
                scene.remove(fpControls.getObject()); 
                playerBody.visible = true; 
                // *** ä¿®æ­£: ç§»å‹• weaponHolder ***
                weaponHolder.position.set(0, 0.5, -0.5); 
                weaponHolder.rotation.y = 0;
                playerBody.add(weaponHolder); 
                // ***
                camera.position.set(playerBody.position.x + 20, playerBody.position.y + 20, playerBody.position.z + 30);
                tpControls.target.copy(playerBody.position); 
                tpControls.update();
                tpControls.enabled = true;
                if (!isMobile) fpControls.unlock(); 
            }
            // åˆ‡æ›è¦–è§’æ™‚æ›´æ–°æº–æ˜Ÿ
            updateAmmoHUD();
        }


        function setupTouchControls() {
            const joystickArea = document.getElementById('joystick-area');
            joystickArea.addEventListener('touchstart', (e) => { e.preventDefault(); joystick.active = true; joystick.initial.set(e.touches[0].clientX, e.touches[0].clientY); });
            joystickArea.addEventListener('touchmove', (e) => {
                if (!joystick.active) return;
                e.preventDefault();
                const currentPos = new THREE.Vector2(e.touches[0].clientX, e.touches[0].clientY);
                joystick.delta.subVectors(currentPos, joystick.initial);
                const handle = document.getElementById('joystick-handle');
                const radius = joystickArea.clientWidth / 4;
                if (joystick.delta.length() > radius) joystick.delta.normalize().multiplyScalar(radius);
                handle.style.transform = `translate(-50%, -50%) translate(${joystick.delta.x}px, ${joystick.delta.y}px)`;
                moveForward = joystick.delta.y < -15;
                moveBackward = joystick.delta.y > 15;
                moveLeft = joystick.delta.x < -15;
                moveRight = joystick.delta.x > 15;
            });
            const joystickEnd = () => {
                joystick.active = false;
                document.getElementById('joystick-handle').style.transform = `translate(-50%, -50%)`;
                moveForward = moveBackward = moveLeft = moveRight = false;
            };
            joystickArea.addEventListener('touchend', joystickEnd);
            joystickArea.addEventListener('touchcancel', joystickEnd);
            
            window.addEventListener('touchstart', (e) => {
                for (const touch of e.changedTouches) {
                    const targetElement = e.target.closest('button, #joystick-area');
                    if (targetElement) continue; 

                    if (touch.clientX > window.innerWidth / 2 && lookTouchId < 0) {
                        lookTouchId = touch.identifier;
                        lookLastPos.set(touch.clientX, touch.clientY);
                    }
                }
            });
            window.addEventListener('touchmove', (e) => {
                for (const touch of e.changedTouches) {
                    if (touch.identifier === lookTouchId) {
                        const currentPos = new THREE.Vector2(touch.clientX, touch.clientY);
                        const deltaX = currentPos.x - lookLastPos.x;
                        const deltaY = currentPos.y - lookLastPos.y;
                        lookLastPos.copy(currentPos);
                        
                        euler.setFromQuaternion(camera.quaternion);
                        euler.y -= deltaX * 0.002;
                        euler.x -= deltaY * 0.002;
                        euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
                        camera.quaternion.setFromEuler(euler);
                    }
                }
            });
            const lookEnd = (e) => {
                for (const touch of e.changedTouches) {
                    if (touch.identifier === lookTouchId) lookTouchId = -1;
                }
            };
            window.addEventListener('touchend', lookEnd);
            window.addEventListener('touchcancel', lookEnd);

            document.getElementById('shoot-button').addEventListener('touchstart', (e) => { e.preventDefault(); isShooting = true; });
            document.getElementById('shoot-button').addEventListener('touchend', () => isShooting = false);
            document.getElementById('jump-button').addEventListener('touchstart', (e) => { e.preventDefault(); if (canJump && !isSliding) { velocity.y += 350; canJump = false; }});
            document.getElementById('reload-button').addEventListener('touchstart', (e) => { e.preventDefault(); reload(); });
            document.getElementById('slide-button').addEventListener('touchstart', (e) => { e.preventDefault(); if (moveForward && !isSliding && slideCooldown <= 0 && canJump) startSlide(); });
            
            // *** æ–°å¢: æ‰‹æ©Ÿç‰ˆåˆ‡æ›æ­¦å™¨æŒ‰éˆ• (å¾ªç’°) ***
            document.getElementById('switch-weapon-button').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                const nextIndex = (currentWeaponIndex + 1) % weapons.length;
                switchWeapon(nextIndex);
            });

            viewToggleButton.addEventListener('touchstart', (e) => { e.preventDefault(); toggleView(); });
        }
        
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump && !isSliding) { velocity.y += 350; canJump = false; } break;
                case 'KeyR': reload(); break;
                case 'ShiftLeft': if (moveForward && !isSliding && slideCooldown <= 0 && canJump) startSlide(); break;
                
                // --- æ–°å¢: æ­¦å™¨åˆ‡æ› ---
                case 'Digit1': switchWeapon(0); break; // é•·æ§
                case 'Digit2': switchWeapon(1); break; // æ‰‹æ§
                case 'Digit3': switchWeapon(2); break; // åŠ
                // ---------------------
            }
        };

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        };
        
        function onMouseWheel(event) {
            if (isFirstPerson) {
                if (!isMobile && !fpControls.isLocked) return;
                camera.fov = Math.max(20, Math.min(75, camera.fov - event.deltaY * 0.05));
                camera.updateProjectionMatrix();
            } else {
                tpControls.doMouseWheel(event);
            }
        }

        function startSlide() {
            isSliding = true;
            canJump = false;
            velocity.z -= 800;
            slideCooldown = 1.5;
            setTimeout(() => isSliding = false, 500);
        }

        // --- æ•µäººæ”¹æˆã€ŒçœŸäººã€æ¨¡å‹ ---
        function spawnTarget() {
            const targetGeometry = new THREE.BoxGeometry(4, 10, 4); // ç˜¦é•·å½¢ç‹€
            const targetMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // ç´…è‰² (éœ§é¢)
            const target = new THREE.Mesh(targetGeometry, targetMaterial);

            const playerStartPos = new THREE.Vector2(100, 100); 
            const spawnPos = new THREE.Vector3();
            const spawnPos2D = new THREE.Vector2(); 
            const safeRadius = 200; 

            do {
                spawnPos.set(
                    (Math.random() - 0.5) * 800, 
                    5, 
                    (Math.random() - 0.5) * 800
                );
                spawnPos2D.set(spawnPos.x, spawnPos.z);
            } while (spawnPos2D.distanceTo(playerStartPos) < safeRadius); 

            target.position.copy(spawnPos); 
            
            target.castShadow = true;
            target.receiveShadow = true;
            
            target.userData.speed = 15 + Math.random() * 10; // é€Ÿåº¦ (15-25)
            target.userData.collider = new THREE.Box3().setFromObject(target);
            scene.add(target);
            targets.push(target);
        }
        // ------------------------

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- æ–°å¢: æ­¦å™¨åˆ‡æ›åŠŸèƒ½ ---
        function switchWeapon(index) {
            if (index === currentWeaponIndex || isReloading) return; // æ›å½ˆä¸­ä¸å‡†åˆ‡æ›

            // éš±è—ç›®å‰æ­¦å™¨
            weapons[currentWeaponIndex].model.visible = false;
            
            // é¡¯ç¤ºæ–°æ­¦å™¨
            currentWeaponIndex = index;
            weapons[currentWeaponIndex].model.visible = true;

            // æ›´æ–° HUD
            updateAmmoHUD();
        }

        function updateAmmoHUD() {
            const currentWeapon = weapons[currentWeaponIndex];
            if (currentWeapon.type === 'melee') {
                ammoElement.textContent = 'âš”ï¸ Sword'; // åŠçš„é¡¯ç¤º
                if (isMobile) document.getElementById('shoot-button').textContent = 'âš”ï¸';
                crosshairElement.style.display = 'none'; // åŠä¸éœ€è¦æº–æ˜Ÿ
            } else {
                ammoElement.textContent = `${currentWeapon.ammo} / ${currentWeapon.maxAmmo}`;
                if (isMobile) document.getElementById('shoot-button').textContent = 'ğŸ”«';
                // *** ä¿®æ­£: åªæœ‰ç¬¬ä¸€äººç¨± & éæ‰‹æ©Ÿ æ‰é¡¯ç¤ºæº–æ˜Ÿ ***
                crosshairElement.style.display = (isFirstPerson && !isMobile) ? 'block' : 'none';
            }
        }
        // -------------------------

        // --- å°„æ“Š/æ”»æ“Š é‚è¼¯æ•´åˆ ---
        function onPrimaryAction(event) {
            const time = performance.now();
            const currentWeapon = weapons[currentWeaponIndex];

            // æª¢æŸ¥å°„é€Ÿ/æ”»é€Ÿ
            if (isReloading || time - lastShotTime < currentWeapon.fireRate) return;
            
            // é›»è…¦ç‰ˆç¬¬ä¸€äººç¨±æª¢æŸ¥
            if (!isMobile && isFirstPerson && event && event.button !== 0) return; 

            lastShotTime = time;

            if (currentWeapon.type === 'raycast') {
                // --- å°„æ“Š (Raycast) ---
                if (currentWeapon.ammo <= 0) {
                    // (å¯åœ¨æ­¤åŠ å€‹ç©ºå€‰éŸ³æ•ˆ)
                    return;
                }
                
                currentWeapon.ammo--;
                updateAmmoHUD();
                
                muzzleFlash.intensity = 20;
                setTimeout(() => muzzleFlash.intensity = 0, 80);

                const shootRaycaster = new THREE.Raycaster();
                shootRaycaster.setFromCamera({ x: 0, y: 0 }, camera);
                const intersects = shootRaycaster.intersectObjects(targets);

                if (intersects.length > 0) {
                    scene.remove(intersects[0].object);
                    targets = targets.filter(t => t !== intersects[0].object);
                    score++;
                    scoreElement.textContent = score;
                    spawnTarget();
                }
            } else if (currentWeapon.type === 'melee') {
                // --- è¿‘æˆ° (Melee) ---
                onMeleeAttack();
            }
        }

        function onMeleeAttack() {
            const currentWeapon = weapons[currentWeaponIndex];
            const playerPos = playerBody.position;
            const playerDirection = new THREE.Vector3();
            camera.getWorldDirection(playerDirection); // æ°¸é ä½¿ç”¨æ”å½±æ©Ÿæœå‘
            playerDirection.y = 0;
            playerDirection.normalize();

            // ç°¡æ˜“æ®ç å‹•ç•«
            const sword = currentWeapon.model;
            const originalRot = sword.rotation.clone();
            sword.rotation.x -= Math.PI / 2;
            setTimeout(() => { sword.rotation.copy(originalRot); }, 150);

            let hitCount = 0;
            for (let i = targets.length - 1; i >= 0; i--) {
                const target = targets[i];
                const distance = playerPos.distanceTo(target.position);
                
                // 1. æª¢æŸ¥è·é›¢
                if (distance <= currentWeapon.range) {
                    // 2. æª¢æŸ¥è§’åº¦
                    const targetDirection = new THREE.Vector3().subVectors(target.position, playerPos).normalize();
                    targetDirection.y = 0; 
                    targetDirection.normalize();
                    const angle = playerDirection.angleTo(targetDirection);

                    if (angle < Math.PI / 3) { // 60 åº¦éŒå½¢
                        scene.remove(target);
                        targets.splice(i, 1);
                        score++;
                        hitCount++;
                    }
                }
            }

            if (hitCount > 0) {
                scoreElement.textContent = score;
                for (let i = 0; i < hitCount; i++) spawnTarget();
            }
        }
        // -------------------------
        
        function reload() {
            const currentWeapon = weapons[currentWeaponIndex];
            
            // åŠæˆ–å½ˆåŒ£å…¨æ»¿æˆ–æ­£åœ¨æ›å½ˆæ™‚ï¼Œä¸åŸ·è¡Œ
            if (isReloading || currentWeapon.type === 'melee' || currentWeapon.ammo === currentWeapon.maxAmmo) return;
            
            isReloading = true;
            ammoElement.textContent = `æ›å½ˆä¸­...`;
            setTimeout(() => { 
                currentWeapon.ammo = currentWeapon.maxAmmo; 
                updateAmmoHUD(); 
                isReloading = false; 
            }, currentWeapon.reloadTime);
        }

        function takeDamage(amount) {
            const time = performance.now();
            if (time - lastDamageTime < 1000) return;
            lastDamageTime = time;
            health = Math.max(0, health - amount);
            healthElement.textContent = health;
            
            damageOverlayElement.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
            setTimeout(() => damageOverlayElement.style.backgroundColor = 'rgba(255, 0, 0, 0)', 100);

            if (health <= 0) endGame();
        }

        function endGame() {
            const instructions = document.getElementById('instructions');
            instructions.innerHTML = `<h1>éŠæˆ²çµæŸ</h1><p>æœ€çµ‚å¾—åˆ†: ${score}</p><p>é»æ“Šä»¥é‡æ–°é–‹å§‹</p>`;
            instructions.removeEventListener('click', startGame);
            instructions.addEventListener('click', () => location.reload());
            if (!isMobile) fpControls.unlock();
            viewToggleButton.style.display = 'none'; // éŠæˆ²çµæŸéš±è—æŒ‰éˆ•
        }

        function checkCollisions() {
            const playerHeight = isSliding ? 9 : 18; 
            
            playerColliderCenter.set(playerBody.position.x, playerBody.position.y, playerBody.position.z);
            playerColliderSize.set(4, playerHeight, 4); 
            playerCollider.setFromCenterAndSize(playerColliderCenter, playerColliderSize);
            
            for (const target of targets) {
                if (playerCollider.intersectsBox(target.userData.collider)) {
                    takeDamage(10);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            const gameActive = isGameActive(); 

            if (slideCooldown > 0) slideCooldown -= delta;

            // *** ä¿®æ­£: æª¢æŸ¥ isShooting (æ‰‹æ©Ÿè§¸æ§) ***
            if (isShooting && gameActive) {
                onPrimaryAction({}); // å‘¼å«æ•´åˆçš„æ”»æ“Šå‡½å¼
            }
            
            if (gameActive) {
                const player = playerBody; 
                if (isFirstPerson) {
                    player.quaternion.copy(camera.quaternion);
                }

                const targetYPosition = isSliding ? 4.5 : 9;
                player.position.y += (targetYPosition - player.position.y) * 20 * delta;

                raycaster.ray.origin.copy(player.position);
                raycaster.ray.origin.y = player.position.y - (18/2) + 1; 
                const onObject = raycaster.intersectObjects(groundObjects, false).length > 0;

                velocity.x -= velocity.x * 10 * delta;
                velocity.z -= velocity.z * 10 * delta;
                velocity.y -= 9.8 * 100 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (!isSliding) {
                    if (moveForward || moveBackward) velocity.z -= direction.z * 400 * delta;
                    if (moveLeft || moveRight) velocity.x -= direction.x * 400 * delta;
                }
                
                if (onObject) {
                    velocity.y = Math.max(0, velocity.y);
                    if (!isSliding) canJump = true;
                }

                if(isMobile) {
                    const forward = new THREE.Vector3();
                    camera.getWorldDirection(forward);
                    forward.y = 0; 
                    forward.normalize();
                    
                    const right = new THREE.Vector3().crossVectors(camera.up, forward).normalize();
                    
                    const moveDirection = new THREE.Vector3();
                    moveDirection.add(forward.multiplyScalar(velocity.z * delta));
                    moveDirection.add(right.multiplyScalar(velocity.x * delta));
                    
                    player.position.add(moveDirection); 

                } else {
                    if (isFirstPerson) {
                         player.translateX(-velocity.x * delta);
                         player.translateZ(velocity.z * delta);
                    } else {
                        const forward = new THREE.Vector3();
                        camera.getWorldDirection(forward);
                        forward.y = 0;
                        forward.normalize();
                        const right = new THREE.Vector3().crossVectors(camera.up, forward).normalize();
                        const moveDirection = new THREE.Vector3();
                        moveDirection.add(forward.multiplyScalar(velocity.z * delta));
                        moveDirection.add(right.multiplyScalar(velocity.x * delta));
                        player.position.add(moveDirection);
                    }
                }

                player.position.y += velocity.y * delta;
                
                if (player.position.y < targetYPosition) {
                    velocity.y = 0;
                    player.position.y = targetYPosition;
                    if (!isSliding) canJump = true;
                }

                if (isFirstPerson) {
                    fpControls.getObject().position.copy(playerBody.position);
                } else {
                    tpControls.target.copy(playerBody.position); 
                    tpControls.update(); 
                    
                    const moveLengthSq = (velocity.z * velocity.z) + (velocity.x * velocity.x);
                    if (moveLengthSq > 0.01) { 
                        const cameraRotation = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
                        player.rotation.y = cameraRotation.y;
                    }
                }

                checkCollisions(); 
            }

            // æ•µäººç§»å‹•èˆ‡ AI (è¿½è¹¤ç©å®¶)
            targets.forEach(target => {
                const playerPos = playerBody.position;
                
                const targetDirection = new THREE.Vector3().subVectors(playerPos, target.position).normalize();
                targetDirection.y = 0; 
                target.position.add(targetDirection.multiplyScalar(target.userData.speed * delta));
                
                target.userData.collider.setFromObject(target);
                
                target.lookAt(playerPos.x, target.position.y, playerPos.z); 
            });

            prevTime = time;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>


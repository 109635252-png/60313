<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <title>絕地求生 (武器系統)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans TC', sans-serif;
            margin: 0;
            background-color: #000;
            color: #fff;
            overflow: hidden; /* 隱藏滾動條 */
        }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
        }
        #instructions {
            width: 80%;
            max-width: 600px;
            cursor: pointer;
        }
        #instructions h1 {
            font-size: 3em;
        }
        #instructions p {
            font-size: 1.2em;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px; /* 調整大小 */
            height: 8px;
            border: 2px solid rgba(255, 255, 255, 0.7); /* 稍細、半透明 */
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 5px rgba(0,0,0,0.8); /* 加上陰影以應對亮背景 */
            z-index: 10;
            display: none; /* 預設隱藏 */
        }
        
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 1.5em;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 8px;
            z-index: 10;
            display: none; /* 預設隱藏 */
            min-width: 200px;
        }
        .hud-item {
            margin-bottom: 5px;
        }
        
        /* 手機觸控 UI */
        #touch-controls {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
        }

        #joystick-area {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 150px;
            height: 150px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            pointer-events: auto;
        }

        #joystick-handle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 70px;
            height: 70px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.1s;
        }

        #action-buttons {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: auto;
        }

        #action-buttons button {
            width: 65px;
            height: 65px;
            margin: 8px 0;
            font-size: 2em;
            background-color: rgba(255, 255, 255, 0.3); /* 更透明 */
            border: 1px solid rgba(255, 255, 255, 0.4); /* 加上邊框 */
            border-radius: 50%;
            color: white;
            padding: 0;
            line-height: 65px;
            text-align: center;
            user-select: none; /* 防止選取文字 */
            backdrop-filter: blur(5px); /* 毛玻璃效果 */
            transition: background-color 0.1s;
        }

        /* *** 新增: 切換武器按鈕的大小 *** */
        #switch-weapon-button {
            width: 60px;
            height: 60px;
            line-height: 60px;
            font-size: 1.8em;
            margin-top: 15px; /* 把它放在最上面 */
            order: -1; /* 讓它顯示在最上面 */
        }
        
        #action-buttons button:active {
            background-color: rgba(255, 255, 255, 0.6);
        }
        
        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0);
            z-index: 50;
            pointer-events: none;
            transition: background-color 0.1s ease-out;
        }

        /* 視角切換按鈕 */
        #view-toggle-button {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            font-size: 1.2em;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            z-index: 10;
            backdrop-filter: blur(5px);
            display: none; /* 遊戲開始後才顯示 */
        }
        #view-toggle-button:active {
            background-color: rgba(0, 0, 0, 0.7);
        }
    </style>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <h1>絕地求生 (武器系統)</h1>
            <p id="start-prompt" style="font-size: 1.5em;">點擊螢幕開始遊戲</p>
            <p id="controls-info">
                W, A, S, D = 移動<br/>
                Shift = 滑鏟 (需向前移動時)<br/>
                空白鍵 = 跳躍<br/>
                滑鼠 = 環顧四周<br/>
                滑鼠左鍵 = 射擊 / 攻擊<br/>
                滑鼠滾輪 = 縮放瞄準<br/>
                R = 換彈<br/>
                ESC = 解鎖滑鼠<br/>
                V = 切換視角 (第一/第三人稱)<br/>
                1, 2, 3 = 切換武器 (長槍/手槍/劍)
            </p>
        </div>
    </div>

    <div id="damage-overlay"></div>
    
    <div id="crosshair"></div>
    <div id="hud">
        <div class="hud-item">❤️ 血量: <span id="health">100</span></div>
        <div class="hud-item">彈藥: <span id="ammo">100 / 100</span></div>
        <div class="hud-item">🎯 分數: <span id="score">0</span></div>
    </div>
    
    <div id="touch-controls" style="display: none;">
        <div id="joystick-area">
            <div id="joystick-handle"></div>
        </div>
        <div id="action-buttons">
            <!-- *** 新增: 切換武器按鈕 *** -->
            <button id="switch-weapon-button">🔁</button>
            <button id="shoot-button">🔫</button>
            <button id="reload-button">🔄</button>
            <button id="slide-button">🏃</button>
            <button id="jump-button">🔼</button>
        </div>
    </div>

    <button id="view-toggle-button">第三人稱</button> <!-- 視角切換按鈕 --><script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { PointerLockControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/PointerLockControls.js';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js'; // 引入 OrbitControls

        let camera, scene, renderer, controls;
        let fpControls; // 第一人稱控制
        let tpControls; // 第三人稱控制
        let isFirstPerson = true; // 預設為第一人稱

        let playerBody; // 玩家的實際模型 (第三人稱時可見)
        
        // --- 武器系統 ---
        let weaponHolder; // 容納所有武器的群組
        let weapons = []; // 儲存武器資料
        let currentWeaponIndex = 0; // 目前武器索引
        let muzzleFlash;
        // ---

        let objects = []; // 用於碰撞偵測 (地板、障礙物)
        let groundObjects = []; // 專門用於地面偵測
        let targets = []; // 專門存放目標方塊 (敵人)
        let raycaster;
        

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let isReloading = false;
        let isSliding = false;
        let slideCooldown = 0;
        let isShooting = false;
        let lastShotTime = 0;

        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // 玩家狀態
        let score = 0;
        let health = 100;
        // (彈藥變數移至 weapons 陣列)
        let lastDamageTime = 0;

        // --- 效能優化：碰撞偵測物件 ---
        let playerCollider = new THREE.Box3();
        let playerColliderCenter = new THREE.Vector3();
        let playerColliderSize = new THREE.Vector3();
        // ------------------------------

        // 手機控制相關
        const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        const PI_2 = Math.PI / 2;
        let lookTouchId = -1;
        const lookLastPos = new THREE.Vector2();
        const joystick = { active: false, initial: new THREE.Vector2(), delta: new THREE.Vector2() };

        // HUD Elements
        const scoreElement = document.getElementById('score');
        const healthElement = document.getElementById('health');
        const ammoElement = document.getElementById('ammo');
        const hudElement = document.getElementById('hud');
        const crosshairElement = document.getElementById('crosshair');
        const damageOverlayElement = document.getElementById('damage-overlay');
        const viewToggleButton = document.getElementById('view-toggle-button');

        // Texture Loader
        const textureLoader = new THREE.TextureLoader();

        init();
        animate();

        function init() {
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(100, 10, 130); // 稍微調整初始鏡頭
            
            scene = new THREE.Scene();
            
            // --- 天空盒 ---
            const skyboxTextures = [
                'https://threejs.org/examples/textures/cube/Bridge2/posx.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/negx.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/posy.jpg', // Up
                'https://threejs.org/examples/textures/cube/Bridge2/negy.jpg', // Down
                'https://threejs.org/examples/textures/cube/Bridge2/posz.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/negz.jpg',
            ];
            const cubeTextureLoader = new THREE.CubeTextureLoader();
            scene.background = cubeTextureLoader.load(skyboxTextures);
            // -----------

            scene.fog = new THREE.Fog(0xcce0ff, 0, 750); // 霧的顏色調整為更配合天空

            const light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.9);
            light.position.set(0.5, 1, 0.75);
            scene.add(light);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight.position.set(-100, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 100;
            dirLight.shadow.camera.bottom = -100;
            dirLight.shadow.camera.left = -100;
            dirLight.shadow.camera.right = 100;
            scene.add(dirLight);

            raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 10);

            // --- 地板 (草皮) ---
            textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg', (grassTexture) => { // 換成綠色草地
                grassTexture.wrapS = THREE.RepeatWrapping;
                grassTexture.wrapT = THREE.RepeatWrapping;
                grassTexture.repeat.set(200, 200); // 重複貼圖
                const floor = new THREE.Mesh(
                    new THREE.PlaneGeometry(2000, 2000, 100, 100),
                    new THREE.MeshLambertMaterial({ map: grassTexture })
                );
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                scene.add(floor);
                groundObjects.push(floor);
                objects.push(floor); // 地板也要參與一般碰撞
            });
            // ------------------

            // 牆壁和障礙物
            const boxGeometry = new THREE.BoxGeometry(20, 20, 20);
            for (let i = 0; i < 50; i++) {
                const box = new THREE.Mesh(boxGeometry, new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff }));
                box.position.set(Math.floor(Math.random() * 20 - 10) * 20, 10, Math.floor(Math.random() * 20 - 10) * 20);
                box.castShadow = true;
                box.receiveShadow = true;
                scene.add(box);
                objects.push(box); 
                groundObjects.push(box); 
            }

            // 玩家的第三人稱模型
            const playerGeometry = new THREE.BoxGeometry(4, 18, 4); // 設為一個細長的盒子代表玩家身體
            const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x0077ff });
            playerBody = new THREE.Mesh(playerGeometry, playerMaterial);
            playerBody.position.set(100, 9, 100); 
            playerBody.castShadow = true;
            playerBody.receiveShadow = true;
            scene.add(playerBody);
            
            // --- 武器模型系統 ---
            weaponHolder = new THREE.Group();
            weaponHolder.position.set(0.5, -0.4, -1.2); // FP 預設位置
            weaponHolder.rotation.y = -0.1;

            const gunMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.8 });
            const swordMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.2, metalness: 1.0 });

            // 1. 長槍 (Rifle)
            const rifleModel = new THREE.Group();
            const rifleBody = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 1), gunMaterial);
            const rifleBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.8, 16), gunMaterial);
            rifleBarrel.position.z = -0.9;
            rifleBarrel.rotation.x = Math.PI / 2;
            rifleModel.add(rifleBody, rifleBarrel);
            
            muzzleFlash = new THREE.PointLight(0xffa500, 0, 50, 2);
            muzzleFlash.position.set(0, 0, -0.8);
            rifleBarrel.add(muzzleFlash); // 槍口火焰只加在長槍上
            
            // 2. 手槍 (Pistol)
            const pistolModel = new THREE.Group();
            const pistolBody = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.5), gunMaterial);
            const pistolBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.4, 16), gunMaterial);
            pistolBarrel.position.z = -0.45;
            pistolBarrel.rotation.x = Math.PI / 2;
            pistolModel.add(pistolBody, pistolBarrel);
            pistolModel.visible = false; // 預設隱藏

            // 3. 劍 (Sword)
            const swordModel = new THREE.Group();
            const swordBlade = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.2, 1.5), swordMaterial);
            swordBlade.position.z = -0.6;
            const swordHilt = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.3), gunMaterial);
            swordHilt.position.z = 0.3;
            const swordGuard = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.3, 0.1), gunMaterial);
            swordGuard.position.z = 0.1;
            swordModel.add(swordBlade, swordHilt, swordGuard);
            swordModel.visible = false; // 預設隱藏

            // 將所有武器加入 weaponHolder
            weaponHolder.add(rifleModel);
            weaponHolder.add(pistolModel);
            weaponHolder.add(swordModel);
            camera.add(weaponHolder); // 預設武器在第一人稱攝影機上

            // 初始化武器資料
            weapons = [
                { 
                    name: 'Rifle', 
                    model: rifleModel, 
                    ammo: 100, 
                    maxAmmo: 100, 
                    fireRate: 150, // ms
                    reloadTime: 1500, // ms
                    type: 'raycast' 
                },
                { 
                    name: 'Pistol', 
                    model: pistolModel, 
                    ammo: 15, 
                    maxAmmo: 15, 
                    fireRate: 400,
                    reloadTime: 1000,
                    type: 'raycast' 
                },
                { 
                    name: 'Sword', 
                    model: swordModel, 
                    ammo: 0, // N/A
                    maxAmmo: 0, // N/A
                    fireRate: 500, // attack speed
                    reloadTime: 0,
                    type: 'melee',
                    range: 12 // melee range
                }
            ];
            // --- 武器系統結束 ---
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');

            // --- 第一人稱控制器 ---
            fpControls = new PointerLockControls(camera, document.body);
            // --------------------

            // --- 第三人稱控制器 ---
            tpControls = new OrbitControls(camera, renderer.domElement);
            tpControls.enableDamping = true;
            tpControls.dampingFactor = 0.25;
            tpControls.maxDistance = 50;
            tpControls.minDistance = 10;
            tpControls.target.copy(playerBody.position);
            tpControls.enabled = false;
            // --------------------

            // 初始敵人
            for (let i = 0; i < 50; i++) spawnTarget();

            if (isMobile) {
                document.getElementById('touch-controls').style.display = 'block';
                document.getElementById('controls-info').innerHTML = '左側搖桿 = 移動<br/>右側螢幕 = 轉動視角<br/>右下角按鈕 = 各項動作<br/>左上角按鈕 = 切換視角<br/>右上角按鈕 = 循環切換武器';
                instructions.addEventListener('click', startGame);
                setupTouchControls();
            } else {
                scene.add(fpControls.getObject()); 
                instructions.addEventListener('click', () => fpControls.lock());
                fpControls.addEventListener('lock', () => { 
                    instructions.style.display = 'none'; 
                    blocker.style.display = 'none'; 
                    hudElement.style.display = 'block'; 
                    crosshairElement.style.display = 'block'; 
                    viewToggleButton.style.display = 'block';
                });
                fpControls.addEventListener('unlock', () => { 
                    blocker.style.display = 'flex'; 
                    instructions.style.display = ''; 
                    hudElement.style.display = 'none'; 
                    crosshairElement.style.display = 'none'; 
                    viewToggleButton.style.display = 'none';
                });
                document.addEventListener('mousedown', (e) => { 
                    // *** 修正: 呼叫 isGameActive ***
                    if (isGameActive()) onPrimaryAction(e); // 統一呼叫
                });
            }
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('wheel', onMouseWheel);
            window.addEventListener('resize', onWindowResize);

            viewToggleButton.addEventListener('click', toggleView);
            document.addEventListener('keydown', (event) => {
                // *** 修正: 呼叫 isGameActive ***
                if (event.code === 'KeyV' && isGameActive()) {
                    toggleView();
                }
            });

            // 初始 HUD
            updateAmmoHUD();
        }

        function isGameActive() {
             return isMobile ? (document.getElementById('blocker').style.display === 'none') : fpControls.isLocked || !isFirstPerson;
        }

        function startGame() {
            document.getElementById('blocker').style.display = 'none';
            hudElement.style.display = 'block';
            crosshairElement.style.display = 'block';
            viewToggleButton.style.display = 'block';
        }

        function toggleView() {
            isFirstPerson = !isFirstPerson;
            if (isFirstPerson) {
                // 從第三人稱切換到第一人稱
                viewToggleButton.textContent = '第三人稱';
                crosshairElement.style.display = 'block';
                camera.position.copy(playerBody.position); 
                camera.rotation.set(0, 0, 0); 
                fpControls.getObject().position.copy(playerBody.position); 
                fpControls.getObject().rotation.copy(camera.rotation);
                scene.add(fpControls.getObject()); 
                playerBody.visible = false; 
                // *** 修正: 移動 weaponHolder ***
                weaponHolder.position.set(0.5, -0.4, -1.2); 
                weaponHolder.rotation.y = -0.1;
                camera.add(weaponHolder); 
                // ***
                tpControls.enabled = false;
                if (!isMobile) fpControls.lock();
            } else {
                // 從第一人稱切換到第三人稱
                viewToggleButton.textContent = '第一人稱';
                crosshairElement.style.display = 'none'; 
                scene.remove(fpControls.getObject()); 
                playerBody.visible = true; 
                // *** 修正: 移動 weaponHolder ***
                weaponHolder.position.set(0, 0.5, -0.5); 
                weaponHolder.rotation.y = 0;
                playerBody.add(weaponHolder); 
                // ***
                camera.position.set(playerBody.position.x + 20, playerBody.position.y + 20, playerBody.position.z + 30);
                tpControls.target.copy(playerBody.position); 
                tpControls.update();
                tpControls.enabled = true;
                if (!isMobile) fpControls.unlock(); 
            }
            // 切換視角時更新準星
            updateAmmoHUD();
        }


        function setupTouchControls() {
            const joystickArea = document.getElementById('joystick-area');
            joystickArea.addEventListener('touchstart', (e) => { e.preventDefault(); joystick.active = true; joystick.initial.set(e.touches[0].clientX, e.touches[0].clientY); });
            joystickArea.addEventListener('touchmove', (e) => {
                if (!joystick.active) return;
                e.preventDefault();
                const currentPos = new THREE.Vector2(e.touches[0].clientX, e.touches[0].clientY);
                joystick.delta.subVectors(currentPos, joystick.initial);
                const handle = document.getElementById('joystick-handle');
                const radius = joystickArea.clientWidth / 4;
                if (joystick.delta.length() > radius) joystick.delta.normalize().multiplyScalar(radius);
                handle.style.transform = `translate(-50%, -50%) translate(${joystick.delta.x}px, ${joystick.delta.y}px)`;
                moveForward = joystick.delta.y < -15;
                moveBackward = joystick.delta.y > 15;
                moveLeft = joystick.delta.x < -15;
                moveRight = joystick.delta.x > 15;
            });
            const joystickEnd = () => {
                joystick.active = false;
                document.getElementById('joystick-handle').style.transform = `translate(-50%, -50%)`;
                moveForward = moveBackward = moveLeft = moveRight = false;
            };
            joystickArea.addEventListener('touchend', joystickEnd);
            joystickArea.addEventListener('touchcancel', joystickEnd);
            
            window.addEventListener('touchstart', (e) => {
                for (const touch of e.changedTouches) {
                    const targetElement = e.target.closest('button, #joystick-area');
                    if (targetElement) continue; 

                    if (touch.clientX > window.innerWidth / 2 && lookTouchId < 0) {
                        lookTouchId = touch.identifier;
                        lookLastPos.set(touch.clientX, touch.clientY);
                    }
                }
            });
            window.addEventListener('touchmove', (e) => {
                for (const touch of e.changedTouches) {
                    if (touch.identifier === lookTouchId) {
                        const currentPos = new THREE.Vector2(touch.clientX, touch.clientY);
                        const deltaX = currentPos.x - lookLastPos.x;
                        const deltaY = currentPos.y - lookLastPos.y;
                        lookLastPos.copy(currentPos);
                        
                        euler.setFromQuaternion(camera.quaternion);
                        euler.y -= deltaX * 0.002;
                        euler.x -= deltaY * 0.002;
                        euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
                        camera.quaternion.setFromEuler(euler);
                    }
                }
            });
            const lookEnd = (e) => {
                for (const touch of e.changedTouches) {
                    if (touch.identifier === lookTouchId) lookTouchId = -1;
                }
            };
            window.addEventListener('touchend', lookEnd);
            window.addEventListener('touchcancel', lookEnd);

            document.getElementById('shoot-button').addEventListener('touchstart', (e) => { e.preventDefault(); isShooting = true; });
            document.getElementById('shoot-button').addEventListener('touchend', () => isShooting = false);
            document.getElementById('jump-button').addEventListener('touchstart', (e) => { e.preventDefault(); if (canJump && !isSliding) { velocity.y += 350; canJump = false; }});
            document.getElementById('reload-button').addEventListener('touchstart', (e) => { e.preventDefault(); reload(); });
            document.getElementById('slide-button').addEventListener('touchstart', (e) => { e.preventDefault(); if (moveForward && !isSliding && slideCooldown <= 0 && canJump) startSlide(); });
            
            // *** 新增: 手機版切換武器按鈕 (循環) ***
            document.getElementById('switch-weapon-button').addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                const nextIndex = (currentWeaponIndex + 1) % weapons.length;
                switchWeapon(nextIndex);
            });

            viewToggleButton.addEventListener('touchstart', (e) => { e.preventDefault(); toggleView(); });
        }
        
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump && !isSliding) { velocity.y += 350; canJump = false; } break;
                case 'KeyR': reload(); break;
                case 'ShiftLeft': if (moveForward && !isSliding && slideCooldown <= 0 && canJump) startSlide(); break;
                
                // --- 新增: 武器切換 ---
                case 'Digit1': switchWeapon(0); break; // 長槍
                case 'Digit2': switchWeapon(1); break; // 手槍
                case 'Digit3': switchWeapon(2); break; // 劍
                // ---------------------
            }
        };

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        };
        
        function onMouseWheel(event) {
            if (isFirstPerson) {
                if (!isMobile && !fpControls.isLocked) return;
                camera.fov = Math.max(20, Math.min(75, camera.fov - event.deltaY * 0.05));
                camera.updateProjectionMatrix();
            } else {
                tpControls.doMouseWheel(event);
            }
        }

        function startSlide() {
            isSliding = true;
            canJump = false;
            velocity.z -= 800;
            slideCooldown = 1.5;
            setTimeout(() => isSliding = false, 500);
        }

        // --- 敵人改成「真人」模型 ---
        function spawnTarget() {
            const targetGeometry = new THREE.BoxGeometry(4, 10, 4); // 瘦長形狀
            const targetMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // 紅色 (霧面)
            const target = new THREE.Mesh(targetGeometry, targetMaterial);

            const playerStartPos = new THREE.Vector2(100, 100); 
            const spawnPos = new THREE.Vector3();
            const spawnPos2D = new THREE.Vector2(); 
            const safeRadius = 200; 

            do {
                spawnPos.set(
                    (Math.random() - 0.5) * 800, 
                    5, 
                    (Math.random() - 0.5) * 800
                );
                spawnPos2D.set(spawnPos.x, spawnPos.z);
            } while (spawnPos2D.distanceTo(playerStartPos) < safeRadius); 

            target.position.copy(spawnPos); 
            
            target.castShadow = true;
            target.receiveShadow = true;
            
            target.userData.speed = 15 + Math.random() * 10; // 速度 (15-25)
            target.userData.collider = new THREE.Box3().setFromObject(target);
            scene.add(target);
            targets.push(target);
        }
        // ------------------------

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 新增: 武器切換功能 ---
        function switchWeapon(index) {
            if (index === currentWeaponIndex || isReloading) return; // 換彈中不准切換

            // 隱藏目前武器
            weapons[currentWeaponIndex].model.visible = false;
            
            // 顯示新武器
            currentWeaponIndex = index;
            weapons[currentWeaponIndex].model.visible = true;

            // 更新 HUD
            updateAmmoHUD();
        }

        function updateAmmoHUD() {
            const currentWeapon = weapons[currentWeaponIndex];
            if (currentWeapon.type === 'melee') {
                ammoElement.textContent = '⚔️ Sword'; // 劍的顯示
                if (isMobile) document.getElementById('shoot-button').textContent = '⚔️';
                crosshairElement.style.display = 'none'; // 劍不需要準星
            } else {
                ammoElement.textContent = `${currentWeapon.ammo} / ${currentWeapon.maxAmmo}`;
                if (isMobile) document.getElementById('shoot-button').textContent = '🔫';
                // *** 修正: 只有第一人稱 & 非手機 才顯示準星 ***
                crosshairElement.style.display = (isFirstPerson && !isMobile) ? 'block' : 'none';
            }
        }
        // -------------------------

        // --- 射擊/攻擊 邏輯整合 ---
        function onPrimaryAction(event) {
            const time = performance.now();
            const currentWeapon = weapons[currentWeaponIndex];

            // 檢查射速/攻速
            if (isReloading || time - lastShotTime < currentWeapon.fireRate) return;
            
            // 電腦版第一人稱檢查
            if (!isMobile && isFirstPerson && event && event.button !== 0) return; 

            lastShotTime = time;

            if (currentWeapon.type === 'raycast') {
                // --- 射擊 (Raycast) ---
                if (currentWeapon.ammo <= 0) {
                    // (可在此加個空倉音效)
                    return;
                }
                
                currentWeapon.ammo--;
                updateAmmoHUD();
                
                muzzleFlash.intensity = 20;
                setTimeout(() => muzzleFlash.intensity = 0, 80);

                const shootRaycaster = new THREE.Raycaster();
                shootRaycaster.setFromCamera({ x: 0, y: 0 }, camera);
                const intersects = shootRaycaster.intersectObjects(targets);

                if (intersects.length > 0) {
                    scene.remove(intersects[0].object);
                    targets = targets.filter(t => t !== intersects[0].object);
                    score++;
                    scoreElement.textContent = score;
                    spawnTarget();
                }
            } else if (currentWeapon.type === 'melee') {
                // --- 近戰 (Melee) ---
                onMeleeAttack();
            }
        }

        function onMeleeAttack() {
            const currentWeapon = weapons[currentWeaponIndex];
            const playerPos = playerBody.position;
            const playerDirection = new THREE.Vector3();
            camera.getWorldDirection(playerDirection); // 永遠使用攝影機朝向
            playerDirection.y = 0;
            playerDirection.normalize();

            // 簡易揮砍動畫
            const sword = currentWeapon.model;
            const originalRot = sword.rotation.clone();
            sword.rotation.x -= Math.PI / 2;
            setTimeout(() => { sword.rotation.copy(originalRot); }, 150);

            let hitCount = 0;
            for (let i = targets.length - 1; i >= 0; i--) {
                const target = targets[i];
                const distance = playerPos.distanceTo(target.position);
                
                // 1. 檢查距離
                if (distance <= currentWeapon.range) {
                    // 2. 檢查角度
                    const targetDirection = new THREE.Vector3().subVectors(target.position, playerPos).normalize();
                    targetDirection.y = 0; 
                    targetDirection.normalize();
                    const angle = playerDirection.angleTo(targetDirection);

                    if (angle < Math.PI / 3) { // 60 度錐形
                        scene.remove(target);
                        targets.splice(i, 1);
                        score++;
                        hitCount++;
                    }
                }
            }

            if (hitCount > 0) {
                scoreElement.textContent = score;
                for (let i = 0; i < hitCount; i++) spawnTarget();
            }
        }
        // -------------------------
        
        function reload() {
            const currentWeapon = weapons[currentWeaponIndex];
            
            // 劍或彈匣全滿或正在換彈時，不執行
            if (isReloading || currentWeapon.type === 'melee' || currentWeapon.ammo === currentWeapon.maxAmmo) return;
            
            isReloading = true;
            ammoElement.textContent = `換彈中...`;
            setTimeout(() => { 
                currentWeapon.ammo = currentWeapon.maxAmmo; 
                updateAmmoHUD(); 
                isReloading = false; 
            }, currentWeapon.reloadTime);
        }

        function takeDamage(amount) {
            const time = performance.now();
            if (time - lastDamageTime < 1000) return;
            lastDamageTime = time;
            health = Math.max(0, health - amount);
            healthElement.textContent = health;
            
            damageOverlayElement.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
            setTimeout(() => damageOverlayElement.style.backgroundColor = 'rgba(255, 0, 0, 0)', 100);

            if (health <= 0) endGame();
        }

        function endGame() {
            const instructions = document.getElementById('instructions');
            instructions.innerHTML = `<h1>遊戲結束</h1><p>最終得分: ${score}</p><p>點擊以重新開始</p>`;
            instructions.removeEventListener('click', startGame);
            instructions.addEventListener('click', () => location.reload());
            if (!isMobile) fpControls.unlock();
            viewToggleButton.style.display = 'none'; // 遊戲結束隱藏按鈕
        }

        function checkCollisions() {
            const playerHeight = isSliding ? 9 : 18; 
            
            playerColliderCenter.set(playerBody.position.x, playerBody.position.y, playerBody.position.z);
            playerColliderSize.set(4, playerHeight, 4); 
            playerCollider.setFromCenterAndSize(playerColliderCenter, playerColliderSize);
            
            for (const target of targets) {
                if (playerCollider.intersectsBox(target.userData.collider)) {
                    takeDamage(10);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            const gameActive = isGameActive(); 

            if (slideCooldown > 0) slideCooldown -= delta;

            // *** 修正: 檢查 isShooting (手機觸控) ***
            if (isShooting && gameActive) {
                onPrimaryAction({}); // 呼叫整合的攻擊函式
            }
            
            if (gameActive) {
                const player = playerBody; 
                if (isFirstPerson) {
                    player.quaternion.copy(camera.quaternion);
                }

                const targetYPosition = isSliding ? 4.5 : 9;
                player.position.y += (targetYPosition - player.position.y) * 20 * delta;

                raycaster.ray.origin.copy(player.position);
                raycaster.ray.origin.y = player.position.y - (18/2) + 1; 
                const onObject = raycaster.intersectObjects(groundObjects, false).length > 0;

                velocity.x -= velocity.x * 10 * delta;
                velocity.z -= velocity.z * 10 * delta;
                velocity.y -= 9.8 * 100 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (!isSliding) {
                    if (moveForward || moveBackward) velocity.z -= direction.z * 400 * delta;
                    if (moveLeft || moveRight) velocity.x -= direction.x * 400 * delta;
                }
                
                if (onObject) {
                    velocity.y = Math.max(0, velocity.y);
                    if (!isSliding) canJump = true;
                }

                if(isMobile) {
                    const forward = new THREE.Vector3();
                    camera.getWorldDirection(forward);
                    forward.y = 0; 
                    forward.normalize();
                    
                    const right = new THREE.Vector3().crossVectors(camera.up, forward).normalize();
                    
                    const moveDirection = new THREE.Vector3();
                    moveDirection.add(forward.multiplyScalar(velocity.z * delta));
                    moveDirection.add(right.multiplyScalar(velocity.x * delta));
                    
                    player.position.add(moveDirection); 

                } else {
                    if (isFirstPerson) {
                         player.translateX(-velocity.x * delta);
                         player.translateZ(velocity.z * delta);
                    } else {
                        const forward = new THREE.Vector3();
                        camera.getWorldDirection(forward);
                        forward.y = 0;
                        forward.normalize();
                        const right = new THREE.Vector3().crossVectors(camera.up, forward).normalize();
                        const moveDirection = new THREE.Vector3();
                        moveDirection.add(forward.multiplyScalar(velocity.z * delta));
                        moveDirection.add(right.multiplyScalar(velocity.x * delta));
                        player.position.add(moveDirection);
                    }
                }

                player.position.y += velocity.y * delta;
                
                if (player.position.y < targetYPosition) {
                    velocity.y = 0;
                    player.position.y = targetYPosition;
                    if (!isSliding) canJump = true;
                }

                if (isFirstPerson) {
                    fpControls.getObject().position.copy(playerBody.position);
                } else {
                    tpControls.target.copy(playerBody.position); 
                    tpControls.update(); 
                    
                    const moveLengthSq = (velocity.z * velocity.z) + (velocity.x * velocity.x);
                    if (moveLengthSq > 0.01) { 
                        const cameraRotation = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
                        player.rotation.y = cameraRotation.y;
                    }
                }

                checkCollisions(); 
            }

            // 敵人移動與 AI (追蹤玩家)
            targets.forEach(target => {
                const playerPos = playerBody.position;
                
                const targetDirection = new THREE.Vector3().subVectors(playerPos, target.position).normalize();
                targetDirection.y = 0; 
                target.position.add(targetDirection.multiplyScalar(target.userData.speed * delta));
                
                target.userData.collider.setFromObject(target);
                
                target.lookAt(playerPos.x, target.position.y, playerPos.z); 
            });

            prevTime = time;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

